"""
Problem 61: Cyclical figurate numbers
https://projecteuler.net/problem=61

Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers
are all figurate (polygonal) numbers and are generated by the following formulae:

Triangle	 	P3,n=n(n+1)/2	 	1, 3, 6, 10, 15, ...
Square	 	    P4,n=n^2	 	    1, 4, 9, 16, 25, ...
Pentagonal	 	P5,n=n(3n−1)/2	 	1, 5, 12, 22, 35, ...
Hexagonal	 	P6,n=n(2n−1)	 	1, 6, 15, 28, 45, ...
Heptagonal	 	P7,n=n(5n−3)/2	 	1, 7, 18, 34, 55, ...
Octagonal	 	P8,n=n(3n−2)	 	1, 8, 21, 40, 65, ...
The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three interesting properties.

1. The set is cyclic, in that the last two digits of each number is the first two digits
of the next number (including the last number with the first).
2. Each polygonal type: triangle (P3,127=8128), square (P4,91=8281), and pentagonal (P5,44=2882),
is represented by a different number in the set.
3. This is the only set of 4-digit numbers with this property.

Find the sum of the only ordered set of six cyclic 4-digit numbers for which each polygonal type:
triangle, square, pentagonal, hexagonal, heptagonal, and octagonal, is represented
by a different number in the set.
"""

from typing import Dict, Callable, Iterable, Set, Tuple
from collections import defaultdict

from src.common.special_numbers import get_triangle_number, get_square_number, \
    get_pentagonal_number, get_hexagonal_number, get_heptagonal_number, \
    get_octagonal_number


def get_number_prefix(number: int) -> str:
    """Get the prefix (first half) of a number `number`."""
    number_str = str(number)
    return number_str[:(len(number_str) // 2)]


def get_number_suffix(number: int) -> str:
    """Get the suffix (second half) of a number `number`."""
    number_str = str(number)
    return number_str[(len(number_str) // 2):]


def get_special_number_prefix_map(
    number_generator_function: Callable[[int], int],
    num_digits: int
) -> Dict[str, Iterable[Tuple[int, int]]]:
    """
    Get a prefix map for all special numbers generated by a given `number_generator_function`
    with `num_digits` digits.
    """
    min_number = 10**(num_digits - 1)
    max_number = 10**num_digits

    number_prefix_map = defaultdict(list)

    idx = 0
    current_number = 0
    while current_number < max_number:
        if current_number >= min_number:
            number_prefix_map[get_number_prefix(current_number)].append((idx, current_number))
        idx += 1
        current_number = number_generator_function(idx)
    return number_prefix_map


def _get_cyclical_figurate_numbers_recursive(
    special_number_types: Set[int],
    number_prefix_maps_map: Dict[int, Dict[str, Iterable[Tuple[int, int]]]],
    current_cyclical_figurate_numbers: Tuple[int, int, int] = None,
    start_prefix: str = None
) -> Iterable[Iterable[Tuple[int, int, int]]]:
    if current_cyclical_figurate_numbers is None:
        current_cyclical_figurate_numbers = []

    if not special_number_types:
        if get_number_suffix(current_cyclical_figurate_numbers[2]) == start_prefix:
            return [[]]
        return []

    result = []
    for special_number_type in special_number_types:
        if current_cyclical_figurate_numbers:
            last_figurate_number = current_cyclical_figurate_numbers[2]
            number_suffix = get_number_suffix(last_figurate_number)
            candidate_numbers = number_prefix_maps_map[special_number_type][number_suffix]
        else:
            candidate_numbers = []
            for _, numbers in number_prefix_maps_map[special_number_type].items():
                candidate_numbers.extend(numbers)

        for idx, number in candidate_numbers:
            if not current_cyclical_figurate_numbers:
                start_prefix = get_number_prefix(number)
            recursive_cyclical_figurate_numbers = _get_cyclical_figurate_numbers_recursive(
                special_number_types - {special_number_type},
                number_prefix_maps_map,
                (special_number_type, idx, number),
                start_prefix,
            )
            if recursive_cyclical_figurate_numbers:
                for recursive_result in recursive_cyclical_figurate_numbers:
                    result.append([(special_number_type, idx, number)] + recursive_result)

    return result


def get_cyclical_figurate_numbers(
    special_number_types: Set[int],
    num_digits: int
) -> Iterable[Iterable[Tuple[int, int, int]]]:
    """Get all cyclical figurate numbers with `num_digits` digits."""
    special_number_generator_functions_map = {
        3: get_triangle_number,
        4: get_square_number,
        5: get_pentagonal_number,
        6: get_hexagonal_number,
        7: get_heptagonal_number,
        8: get_octagonal_number,
    }

    number_prefix_maps_map = {
        number_type: get_special_number_prefix_map(generator_function, num_digits) \
            for number_type, generator_function in special_number_generator_functions_map.items()
    }

    return _get_cyclical_figurate_numbers_recursive(special_number_types, number_prefix_maps_map)


def main() -> None:
    """Main function."""
    num_digits = 4
    end_special_number_type = 8

    special_number_types = set(range(3, end_special_number_type + 1))

    cyclical_figurate_numbers_list = get_cyclical_figurate_numbers(special_number_types, num_digits)
    if len(cyclical_figurate_numbers_list) / len(special_number_types) != 1:
        print(f'There is not just one ordered set of cyclic {num_digits}-digit numbers.')
        print('Stopping...')
        return
    cyclical_figurate_numbers = cyclical_figurate_numbers_list[0]

    cyclical_figurate_numbers_str = [
        f'P{special_number_type},{n}={number}' \
            for special_number_type, n, number in cyclical_figurate_numbers
    ]
    cyclical_figurate_numbers_sum = sum([number for _, _, number in cyclical_figurate_numbers])
    print(f'The ordered set of cyclic {num_digits}-digit numbers ' \
          f'is {cyclical_figurate_numbers_str}.')
    print(f'Their sum is {cyclical_figurate_numbers_sum:,}.')


if __name__ == '__main__':
    main()
